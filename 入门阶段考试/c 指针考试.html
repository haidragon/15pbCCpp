<!DOCTYPE HTML><html><head><style id="wiz_custom_css">html, body {font-size: 12pt;}body {font-family: Helvetica, "Hiragino Sans GB", "微软雅黑", "Microsoft YaHei UI", SimSun, SimHei, arial, sans-serif;line-height: 1.6;margin: 0 auto;padding: 20px 16px;padding: 1.25rem 1rem;}h1, h2, h3, h4, h5, h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}h1 {font-size:20pt;font-size:1.67rem;}h2 {font-size:18pt;font-size:1.5rem;}h3 {font-size:15pt;font-size:1.25rem;}h4 {font-size:14pt;font-size:1.17rem;}h5 {font-size:12pt;font-size:1rem;}h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}div, p, ul, ol, dl, li {margin:0;}blockquote, table, pre, code {margin:8px 0;}ul, ol {padding-left:32px;padding-left:2rem;}ol.wiz-list-level1 > li {list-style-type:decimal;}ol.wiz-list-level2 > li {list-style-type:lower-latin;}ol.wiz-list-level3 > li {list-style-type:lower-roman;}blockquote {padding:0 12px;padding:0 0.75rem;}blockquote > :first-child {margin-top:0;}blockquote > :last-child {margin-bottom:0;}img {border:0;max-width:100%;height:auto !important;margin:2px 0;}table {border-collapse:collapse;border:1px solid #bbbbbb;}td, th {padding:4px 8px;border-collapse:collapse;border:1px solid #bbbbbb;min-height:28px;word-break:break-all;box-sizing: border-box;}.wiz-hide {display:none !important;}


@media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {
    html, body {
        font-size: 17px;
    }

    body {
        line-height: 1.7;
        padding: 0.75rem 0.9375rem;
        color: #353c47;
    }

    h1 {
        font-size: 2.125rem;
    }

    h2 {
        font-size: 1.875rem;
    }

    h3 {
        font-size: 1.625rem;
    }

    h4 {
        font-size: 1.375rem;
    }

    h5 {
        font-size: 1.125rem;
    }

    h6 {
        color: inherit;
    }

    ul, ol {
        padding-left: 2.5rem;
    }

    blockquote {
        padding: 0 0.9375rem;
    }
}

html, body {
    font-family:Helvetica Neue;
    font-size:15px;
    background-color:#FFFFFF;
}</style></head><body class="" ><p></p><div><p class="p1"><span class="s1">1.</span>有指针如下 <span class="s2">int</span> *p =(<span class="s2">int</span> *)<span class="s1">0x1000</span>;执行++p;后，p 的值是（B）</p><p class="p1">A<span class="s1">.0</span>x1008 B<span class="s1">.0</span>x1004 C<span class="s1">.1002</span> D<span class="s1">.1001</span></p><p class="p2"><br></p><p class="p1"><span class="s1">2.</span>设有如下定义：(A)</p><p class="p1"><span class="s2">unsigned</span> <span class="s2">long</span> pulArray[]={<span class="s1">6</span>,<span class="s1">7</span>,<span class="s1">8</span>,<span class="s1">9</span>,<span class="s1">10</span>};</p><p class="p3">unsigned<span class="s3"> </span>long<span class="s3"> *pulArray;</span></p><p class="p1">则下列程序段的输出结果是（） pulPtr = pulArray; *(pulPtr+<span class="s1">2</span>)+=<span class="s1">2</span>;<span class="Apple-converted-space">&nbsp; </span><span class="s4"><i>//arr[2]=10;</i></span></p><p class="p1">printf(<span class="s5">"%d,%d\n"</span>,*pulPtr,*(pulPtr+<span class="s1">2</span>));</p><p class="p4"><span class="s3">A</span>.6<span class="s3"> </span>10<span class="s3"> B</span>.8<span class="s3"> </span>8<span class="s3"> C</span>.0<span class="s3"> </span>2<span class="s3"> D</span>.6<span class="s3"> </span>8</p><p class="p4">3.</p><p class="p1"><span class="s2">int</span> x[<span class="s1">6</span>][<span class="s1">4</span>],(*p)[<span class="s1">4</span>]; p=x;则*(*p+<span class="s1">2</span>)指针哪里(c):<span class="Apple-converted-space">&nbsp; </span><span class="s4"><i>//*(*p+2) *p = x[]<span class="Apple-converted-space">&nbsp; </span>等效写法 *(a[]+2)</i></span></p><p class="p1">A.x[<span class="s1">0</span>][<span class="s1">1</span>] B.x[<span class="s1">1</span>][<span class="s1">0</span>] C.x[<span class="s1">0</span>][<span class="s1">2</span>] D.x[<span class="s1">2</span>][<span class="s1">0</span>]</p><p class="p2"><br></p><p class="p5"><span class="s1">7.</span><span class="s3">*p++ 是自增 p </span><i>//是先解引用 就变成了指针 后 p++;</i></p><p class="p4">12.</p><p class="p1">下列代码运行的结果是运行起来后崩溃</p><p class="p1"><span class="s2">void</span> getmemory(<span class="s2">char</span>*p){</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span>p=(<span class="s2">char</span>*)malloc(<span class="s1">100</span>);</p><p class="p1">}</p><p class="p1"><span class="s2">void</span> main(){</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span><span class="s2">char</span>*str = <span class="s2">NULL</span>;</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span>getmemory(str);</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span>strcpy(str,<span class="s5">"hello,world"</span>);</p><p class="p1">}</p><p class="p5"><i>//等效代码 char* p = str; p(char*)malloc(100); 因此并没有改变<span class="Apple-converted-space">&nbsp; </span>除非 char**p = &amp;str;</i></p><p class="p3"><span class="s6">13.</span>typedef<span class="s3"> </span>struct<span class="s3"> mystruct{</span></p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span><span class="s2">int</span> a;</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span><span class="s2">int</span> b;</p><p class="p1">}new;</p><p class="p1">new arr[<span class="s1">10</span>]={<span class="s1">0</span>};</p><p class="p1">如果对 arr 取”地址”时代表一个结构体不是一个地址</p><p class="p4">14.</p><p class="p3">typedef<span class="s3"> </span>struct<span class="s3"> mystruct{</span></p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span><span class="s2">int</span> a;</p><p class="p1"><span class="Apple-converted-space">&nbsp; &nbsp; </span><span class="s2">int</span> b;</p><p class="p1">}new;</p><p class="p1"><span class="Apple-converted-space">&nbsp;</span>new是一个结构体类型 ( c 中 <span class="s2">struct</span> mystruct才是结构体类型） new如果没有 <span class="s2">typedef</span>就是一个结构变量</p><p class="p2">///////////////////////////////////////////////<br><span style="color:rgb(0, 0, 0);font-family:&quot;Helvetica Neue&quot;font-size:1rem;font-style:normal;font-weight:normal;text-align:start;text-indent:0px;background-color:rgb(255, 255, 255);display:inline !important;"></span><br class="Apple-interchange-newline"></p>1. 有指针如下int *p = (int*)0x1000; 执行++p;后, p的值是（）。 <br></div><div><br></div><div>0x1002<br></div><div><br></div><div>0x1001<br></div><div><br></div><div>0x1008<br></div><div><br></div><div>0x1004<br></div><div><br></div><div>2. 设有如下定义： <br></div><div><br></div><div>&nbsp; &nbsp; unsigned long pulArray[]={6,7,8,9,10};<br></div><div>&nbsp; &nbsp; unsigned long *pulPtr;<br></div><div><br></div><div>&nbsp;  则下列程序段的输出结果是（）。<br></div><div><br></div><div>&nbsp;  pulPtr = pulArray;<br></div><div>&nbsp;  *(pulPtr+2) += 2;<br></div><div>&nbsp;  printf("%d,%d\n",*pulPtr,*(pulPtr+2));<br></div><div><br></div><div> <br></div><div><br></div><div>0 2<br></div><div><br></div><div>8 8<br></div><div><br></div><div>6 8<br></div><div><br></div><div>6 10<br></div><div><br></div><div>3.int x[6][4],(*p)[4]; p=x;则*(*p+2)指向哪里（）。 <br></div><div><br></div><div>x[1][0]<br></div><div><br></div><div>x[0][2]<br></div><div><br></div><div>x[0][1]<br></div><div><br></div><div>x[2][0]<br></div><div><br></div><div>4.关于动态分配说法错误的是( )。 <br></div><div><br></div><div>不能对同一指针(地址)连续两次进行free。<br></div><div><br></div><div>对一个指针free之后，该指针所保存的变量不会改变，这时称该指针为“野指针”。<br></div><div><br></div><div>刚刚分配的动态内存的初始值是不确定的。<br></div><div><br></div><div>不能对指向静态内存区或栈区的指针进行free。<br></div><div><br></div><div>5. 有以下程序, 要求使p指向一个int型的动态存储单元,在横线处应填入的是（）。 <br></div><div><br></div><div>&nbsp; &nbsp; int * p;<br></div><div>&nbsp; &nbsp; p =&nbsp;  ______ malloc(sizeof(int));<br></div><div><br></div><div> <br></div><div><br></div><div>(int*)<br></div><div><br></div><div>(*int)<br></div><div><br></div><div>int<br></div><div><br></div><div>int*<br></div><div><br></div><div>6. 以下说法错误的是( )。 <br></div><div><br></div><div>&nbsp; &nbsp; struct MyStruct{<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;  int nNum;<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;  double * pDouble;<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;  union{<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  char ch;<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double dNum;<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; }U;<br></div><div>&nbsp; &nbsp; }<br></div><div><br></div><div> <br></div><div><br></div><div>指针变量不占用存储空间。<br></div><div><br></div><div>指针可以进行加，减等算术运算。<br></div><div><br></div><div>指针是一个变量。<br></div><div><br></div><div>指针中存放的是地址。<br></div><div><br></div><div>7. *p++ 自增p 还是 p 所指向的变量（）。 <br></div><div><br></div><div>和编译器有关<br></div><div><br></div><div>自增p指向的变量<br></div><div><br></div><div>随机选一个<br></div><div><br></div><div>自增p<br></div><div><br></div><div>8. 若有语句char s1[10], s2[10] = {"books"}; 则能将字符串”books”存放到数组 s1 的正确语句是（）。 <br></div><div><br></div><div>s1 = {“books”};<br></div><div><br></div><div>strcpy_s(s2,sizeof(s2) , s1);<br></div><div><br></div><div>strcpy_s(s1, sizeof(s1), s2));<br></div><div><br></div><div>s1 = s2;<br></div><div><br></div><div>9. 有代码如下,叙述正确的是（）。 <br></div><div><br></div><div>&nbsp; &nbsp; char str1[]&nbsp;  ="15pb";<br></div><div>&nbsp; &nbsp; char str2[]&nbsp;  ={'1','5','p','b'};<br></div><div>&nbsp; &nbsp; char* pStr1 ="15pb";<br></div><div><br></div><div> <br></div><div><br></div><div>str1和str2的大小相等<br></div><div><br></div><div>pStr1的指向的内容可以被修改<br></div><div><br></div><div>变量pStr1的大小为5个字节<br></div><div><br></div><div>str1和str2的内容可以被修改<br></div><div><br></div><div>10. 已知int a[3][4];则下列能表示a[1][2]元素值的是（）。 <br></div><div><br></div><div>(&amp;a[0]+1)[2]<br></div><div><br></div><div>*(a+1+2)<br></div><div><br></div><div>*(a[0]+1)<br></div><div><br></div><div>*(*(a+1)+2)<br></div><div><br></div><div>11. 有指针数组如下: int nArray[3][3]={{0,1,2},{3,4,5},{6,7,8}};int* p = (int*)nArray; 则*(p + 2)的得到的值为（）。 <br></div><div><br></div><div>1<br></div><div><br></div><div>2<br></div><div><br></div><div>6<br></div><div><br></div><div>5<br></div><div><br></div><div>12. 下列代码运行的结果是（）。 <br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; void getmemory(char *p){<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  p=(char*)malloc(100);<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; }<br></div><div><br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; void test(void) {<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char * str = NULL;<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getmemory(str);<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(str,"hello,world");<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%s",str);<br></div><div>&nbsp; &nbsp; &nbsp; }<br></div><div><br></div><div> <br></div><div><br></div><div>输出""<br></div><div><br></div><div>编译错误<br></div><div><br></div><div>程序运行起来后崩溃<br></div><div><br></div><div>输出"hello world"<br></div><div><br></div><div>13. 有以下结构体声明, 该结构体所定义出来的变量一共占用( )字节 <br></div><div><br></div><div>struct MyStruct{<br></div><div>&nbsp; &nbsp; int nNum;<br></div><div>&nbsp; &nbsp; char cNum;<br></div><div>};<br></div><div><br></div><div>12<br></div><div><br></div><div>6<br></div><div><br></div><div>8<br></div><div><br></div><div>5<br></div><div><br></div><div>14.有代码如下, 代码执行后字段cNum的值是( ) 。 <br></div><div><br></div><div>union MyUnion{<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; char cNum;<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; int&nbsp; nNum;<br></div><div><br></div><div>};<br></div><div><br></div><div>union MyUnion u = {0};<br></div><div><br></div><div>u.nNum = 0x12345678;<br></div><div><br></div><div> <br></div><div><br></div><div>0x78<br></div><div><br></div><div>0x1234<br></div><div><br></div><div>0x12<br></div><div><br></div><div>0x12346578<br></div><div><br></div><div>15. 有代码如下,执行之后打印了什么( ) <br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; struct MyStruct{<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  char szBuff[4];<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  int nNum;<br></div><div>&nbsp; &nbsp; &nbsp; };<br></div><div>&nbsp; &nbsp; &nbsp; int nArray[]={0x00616263,12345678};<br></div><div>&nbsp; &nbsp; &nbsp; struct MyStruct* pStc = (struct MyStruct*)nArray;<br></div><div>&nbsp; &nbsp; &nbsp; printf("%s,%d\n" , pStc-&gt;szBuff , pStc-&gt;nNum);<br></div><div><br></div><div> <br></div><div><br></div><div>0x979899,12345678<br></div><div><br></div><div>abc,12345678<br></div><div><br></div><div>0cba,12345678<br></div><div><br></div><div>垃圾数据<br></div><div><br></div><div>16. 在C语言中(源文件后缀为.c), 对于以下定义说法正确的是（）。 <br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; typedef struct ST {<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nNum;<br></div><div>&nbsp; &nbsp; &nbsp; }NEW;<br></div><div><br></div><div> <br></div><div><br></div><div>NEW是一个结构体类型<br></div><div><br></div><div>NEW是一个结构体变量<br></div><div><br></div><div>ST是一个结构体类型<br></div><div><br></div><div>以上的声明形式是非法的<br></div><div><br></div><div>17. 有语句: char *p = "hello,world";则p和字符串"hello,world"分别存储在（）。 <br></div><div><br></div><div>栈区,，栈区<br></div><div><br></div><div>栈区，堆区<br></div><div><br></div><div>堆区，常量数据区<br></div><div><br></div><div>栈区,，常量数据区<br></div><div><br></div><div>18.有以下程序： <br></div><div><br></div><div>void main(){<br></div><div><br></div><div>&nbsp; &nbsp;  union {<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;  unsigned int n;<br></div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;  unsigned char c;<br></div><div><br></div><div>&nbsp; &nbsp;  }u1;<br></div><div><br></div><div>&nbsp; &nbsp;  u1.c = 'A';<br></div><div><br></div><div>&nbsp; &nbsp;  printf("%c\n",u1.n);<br></div><div><br></div><div>}<br></div><div><br></div><div> <br></div><div><br></div><div>A<br></div><div><br></div><div>随机值<br></div><div><br></div><div>65<br></div><div><br></div><div>产生语法错误<br></div><div><br></div><div>19. 在C语言中，可把整数以二进制形式存放到文件中的函数是( )。 <br></div><div><br></div><div>fputc函数<br></div><div><br></div><div>fread函数<br></div><div><br></div><div>fprintf函数<br></div><div><br></div><div>fwrite函数<br></div><div><br></div><div>20. 读取一个文件的步骤是（）： <br></div><div><br></div><div>&nbsp; &nbsp;  1 获取文件大小<br></div><div>&nbsp; &nbsp;  2 使用malloc申请堆空间<br></div><div>&nbsp; &nbsp;  3 使用fopen打开文件<br></div><div>&nbsp; &nbsp;  4 使用fread读取文件内容<br></div><div>&nbsp; &nbsp;  5 使用fclose关闭文件<br></div><div><br></div><div> <br></div><div><br></div><div>3 2 1 4 5<br></div><div><br></div><div>1 2 3 4 5<br></div><div><br></div><div>3 1 2 4 5<br></div><div><br></div><div>2 1 3 4 5<br></div><div><br></div><div>//////////////////////////////////////////////////</div><div>1.B</div><div><img border="0" src="c 指针考试_files/a08113ec-5ac5-4a07-a420-f676776f4d92.png"></div><div>2.A &nbsp;<font color="#ff0000">arr[2]=10</font></div><div><font color="#ff0000">3.C</font></div><div><div><img border="0" src="c 指针考试_files/2416cb6c-75e8-4b29-aa50-00a2048f53cd.png"></div></div><div>4.<font color="#ff0000">A （悬空指针 强拆）</font></div><div><div><img border="0" class="" src="c 指针考试_files/8802afd4-0224-4c74-b999-26e6890014e2.png"></div></div><div>5.A</div><div><br></div><div><div><img border="0" src="c 指针考试_files/38612b64-cc6c-42ca-b6b1-98d52b6ecf5c.png"></div></div><div>6.c</div><div><div><img border="0" class="" src="c 指针考试_files/abe348a1-edb8-426d-a8ef-c90cd357a24a.png"></div></div><div><font color="#ff0000">7.A 它是先解引用 解完引用后 p是一个指针 再p++&nbsp;</font></div><div><div><img border="0" class="" src="c 指针考试_files/196774dd-2377-41fa-885f-1a9a6face411.png"></div></div><div>8.A 要先知道要放的地址大小</div><div>9.C &nbsp; &nbsp; 指针大小固定 4 个字节</div><div><br></div><div><div><img border="0" src="c 指针考试_files/1a324a42-2028-491f-bd52-0f6256f25fcc.png"></div></div><div>10.C</div><div>11.2 变成了一个一维数组</div><div><div><img border="0" class="" src="c 指针考试_files/5bb1ff2a-36d8-4470-9190-e636d5e3ba60.png"></div></div><div>等效 char *p = str; &nbsp; &nbsp;</div><div>p=(char*)malloc(100);</div><div>没有改变 &nbsp; 除非 char **p=&amp;str;</div><div>&nbsp; &nbsp; 12 B</div><div><div><img border="0" class="" src="c 指针考试_files/d6df891c-7930-4428-bfa0-9ef8ed776d0a.png"></div></div><div>13 C 结构体数组 *（p)代表一个结构体不是一个地址 &nbsp;</div><div><div><img border="0" class="" src="c 指针考试_files/c2ddb41e-d087-4420-b724-4eba4c7c0423.png"></div></div><div>14 D &nbsp;<span style="color:rgb(0, 0, 0);font-family:&quot;Helvetica Neue&quot;font-size:1rem;font-style:normal;font-weight:normal;text-align:start;text-indent:0px;background-color:rgb(255, 255, 255);display:inline !important;"><span class="Apple-converted-space">&nbsp;</span>&nbsp;（78 56 34 12）</span></div><div>由于有小端 大端</div><div><div><img border="0" class="" src="c 指针考试_files/c4f1759c-e615-4462-afd9-31186bee1d33.png"></div></div><div>15. &nbsp;63 32 31 00 &nbsp; (答案cba 12345678)</div><div><br></div><div><div><img border="0" class="" src="c 指针考试_files/ad27f623-a0b7-46a8-bcfe-f4710de04a65.png"></div></div><div>16. C &nbsp; (struct st才是） new如果没有 typedef就是一个结构变量</div><div><div><img border="0" class="" src="c 指针考试_files/672c4d91-5aa3-4146-804a-23234df3a1a4.png"></div></div><div>17.B</div><div>18 &nbsp;D 'A'cc cc cc</div><div><div><img border="0" class="" src="c 指针考试_files/dae34782-bdba-4727-b902-b1b8d193f8ab.png"></div><div>19.D</div><div>20A</div><div><br><div><img border="0" class="" src="c 指针考试_files/055f6cd1-f7bb-45f7-9886-9bff367f8921.png"></div></div></div><div>A</div><p></p></body></html>